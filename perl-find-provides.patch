diff -urN perl-5.6.1/find-perl-provides perl-5.6.1-grabba/find-perl-provides
--- perl-5.6.1/find-perl-provides	Thu Jan  1 00:00:00 1970
+++ perl-5.6.1-grabba/find-perl-provides	Sun Mar  3 14:41:39 2002
@@ -0,0 +1,23 @@
+#!/bin/sh
+ulimit -c 0
+
+export LD_LIBRARY_PATH="FPPATH"
+
+filelist=`sed "s/['\"]/\\\&/g"`
+if [ -f __rpm_noautoprovfiles ] ; then
+	for i in `cat __rpm_noautoprovfiles`; do
+		filelist=`echo $filelist | sed "s![[:space:]]*$i[[:space:]]*!!g"`
+	done
+fi
+
+
+echo $filelist|/usr/lib/rpm/find-provides
+provides_perl=`FPPATH/find-perl.prov $filelist`
+if [ -f __rpm_noautoprov ] ; then
+	for i in `cat __rpm_noautoprov`; do
+		provides_perl=`echo $provides_perl | sed "s!\<$i[[:space:]]*!!g"`
+	done
+fi
+
+echo "$provides_perl" | grep -v '^perl(DynaLoader)$'
+
diff -urN perl-5.6.1/find-perl.prov perl-5.6.1-grabba/find-perl.prov
--- perl-5.6.1/find-perl.prov	Thu Jan  1 00:00:00 1970
+++ perl-5.6.1-grabba/find-perl.prov	Sun Mar  3 14:37:16 2002
@@ -0,0 +1,177 @@
+#!FPPATH/perl
+
+# RPM (and it's source code) is covered under two separate licenses.
+
+# The entire code base may be distributed under the terms of the GNU
+# General Public License (GPL), which appears immediately below.
+# Alternatively, all of the source code in the lib subdirectory of the
+# RPM source code distribution as well as any code derived from that
+# code may instead be distributed under the GNU Library General Public
+# License (LGPL), at the choice of the distributor. The complete text
+# of the LGPL appears at the bottom of this file.
+
+# This alternative is allowed to enable applications to be linked
+# against the RPM library (commonly called librpm) without forcing
+# such applications to be distributed under the GPL.
+
+# Any questions regarding the licensing of RPM should be addressed to
+# Erik Troan <ewt@redhat.com>.
+
+# a simple script to print the proper name for perl libraries.
+
+# To save development time I do not parse the perl grammmar but
+# instead just lex it looking for what I want.  I take special care to
+# ignore comments and pod's.
+
+# it would be much better if perl could tell us the proper name of a
+# given script.
+
+# The filenames to scan are either passed on the command line or if
+# that is empty they are passed via stdin.
+
+# If there are lines in the file which match the pattern
+#      (m/^\s*\$VERSION\s*=\s+/)
+# then these are taken to be the version numbers of the modules.
+# Special care is taken with a few known idioms for specifying version
+# numbers of files under rcs/cvs control.
+
+# If there are strings in the file which match the pattern
+#     m/^\s*\$RPM_Provides\s*=\s*["'](.*)['"]/i
+# then these are treated as additional names which are provided by the
+# file and are printed as well.
+
+# I plan to rewrite this in C so that perl is not required by RPM at
+# build time.
+
+# by Ken Estes Mail.com kestes@staff.mail.com
+
+if ("@ARGV") {
+  foreach (@ARGV) {
+     if (! m=(/(doc|usr/src)/|\.(so|gz|ph|pod|h|html|al|ix)$)=) {
+      process_file($_) if -f "$_";
+    }
+  }
+} else {
+
+  # notice we are passed a list of filenames NOT as common in unix the
+  # contents of the file.
+
+  foreach (<>) {
+     if (! m=(/(doc|usr/src)/|\.(so|gz|ph|pod|h|html|al|ix)$)=) {
+      process_file($_) if -f "$_";
+    }
+  }
+}
+
+
+foreach $module (sort keys %require) {
+  if (length($require{$module}) == 0) {
+    print "perl($module)\n";
+  } else {
+
+    # I am not using rpm3.0 so I do not want spaces arround my
+    # operators. Also I will need to change the processing of the
+    # $RPM_* vairable when I upgrade.
+
+    print "perl($module) = $require{$module}\n";
+  }
+}
+
+exit 0;
+
+
+
+sub process_file {
+
+  my ($file) = @_;
+  chomp $file;
+  
+  open(FILE, "<$file")||
+    die("$0: Could not open file: '$file' : $!\n");
+
+  my ($package, $version) = ();
+
+  while (<FILE>) {
+    
+    # skip the documentation
+
+    # we should not need to have item in this if statement (it
+    # properly belongs in the over/back section) but people do not
+    # read the perldoc.
+
+    if ( (m/^=(head1|head2|pod|item)/) .. (m/^=(cut)/ || eof) ) {
+      next;
+    }
+    
+    if ( (m/^=(over)/) .. (m/^=(back)/ || eof) ) {
+      next;
+    }
+    
+    # skip the data section
+    if (m/^__(DATA|END)__$/) {
+      last;
+    }
+
+    # not everyone puts the package name of the file as the first
+    # package name so we report all namespaces as if they were
+    # provided packages (really ugly).
+
+    if (m/^\s*package\s+([_:a-zA-Z0-9]+)\s*;/ && !$require{$1}) {
+      $package=$1;
+      undef $version;
+      $require{$package}=undef;
+    }
+
+    # after we found the package name take the first assignment to
+    # $VERSION as the version number. Exporter requires that the
+    # variable be called VERSION so we are safe.
+
+    # here are examples of VERSION lines from the perl distribution
+
+    #FindBin.pm:$VERSION = $VERSION = sprintf("%d.%02d", q$Revision$ =~ /(\d+)\.(\d+)/);
+    #ExtUtils/Install.pm:$VERSION = substr q$Revision$, 10;
+    #CGI/Apache.pm:$VERSION = (qw$Revision$)[1];
+    #DynaLoader.pm:$VERSION = $VERSION = "1.03";     # avoid typo warning
+    #Cwd.pm:our $VERSION = '2.04';
+
+    # here is example of VERSION line from RPC::PlClient module
+
+    # RPC/PlClient.pm:$RPC::PlClient::VERSION = '0.2016';
+
+    if ( 
+	($package) && 
+	(m/^\s*(our)?\s*\$(${package}::)?VERSION\s*=/)
+       ) {
+
+      # first see if the version string contains the string
+      # '$Revision' this often causes bizzare strings and is the most
+      # common method of non static numbering.
+
+      if (m/(\$Revision: (\d+[.0-9]+))/) {
+	$version= $2; 
+      } elsif (m/[\'\"]?(\d+[.0-9]+)[\'\"]?/) {
+	
+	# look for a static number hard coded in the script
+	
+	$version= $1; 
+      }
+      $require{$package}=$version;
+    }
+    
+    # Each keyword can appear multiple times.  Don't
+    #  bother with datastructures to store these strings,
+    #  if we need to print it print it now.
+	
+    if ( m/^\s*\$RPM_Provides\s*=\s*["'](.*)['"]/i) {
+      foreach $_ (spit(/\s+/, $1)) {
+	print "$_\n";
+      }
+    }
+
+  }
+
+  close(FILE)||
+    die("$0: Could not close file: '$file' : $!\n");
+
+  return ;
+}
